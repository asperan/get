# Get is a toolbox based on git which simplifies the adoption of conventions and some git commands.
# Copyright (C) 2023  Alex Speranza

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program and the additional permissions granted by
# the Lesser GPL.  If not, see <https://www.gnu.org/licenses/>.

# frozen_string_literal: true

# Module with bash completion generation functions
module BashCompletion
  def bash_completion(main_module, command_name)
    generate_functions(main_module, command_name, INITIAL_LEVEL)

    "#{HEADER}\n#{@@function_stack.reverse.join("\n")}"
  end

  private

  INITIAL_LEVEL = 1

  HEADER = <<~HEADER
    #!/usr/bin/env bash
    #
    # This file has been generated by `get complete`.
  HEADER

  @@function_stack = []

  def full_subcommand_name(base, name)
    "#{base}_#{name}"
  end

  def completion_function_definition(name, level, long_options, short_options, subcommands)
    <<~FUNCTION
      _#{name}_completion()
      {
        if [ "${COMP_CWORD}" -eq "#{level}" ] ; then
          COMPREPLY=($(compgen -W "#{(long_options | short_options | subcommands).join(' ')}" -- "${COMP_WORDS[#{level}]}"))
        else
          case "${COMP_WORDS[#{level}]}" in
          #{subcommands.map { |element| subcommand_case_completion(name, element) }.join("\n")}
          *)
            COMPREPLY=()
            ;;
          esac
        fi
      }
    FUNCTION
  end

  def subcommand_case_completion(base, name)
    <<~CASE
      "#{name}")
        _#{full_subcommand_name(base, name)}_completion
        ;;
    CASE
  end

  def generate_functions(command_class, name, level)
    long_options = []
    short_options = []
    subcommands = []

    command_class.class_variable_get(:@@option_parser).specs.each_value do |option|
      long_options.push("--#{option.long}")
      short_options.push("-#{option.short.nil? ? option.long[0] : option.short}") if option.short != :none
    end

    command_class.class_variable_get(:@@subcommands).each_key do |subcommand|
      subcommands.push(subcommand.to_s)
    end

    @@function_stack.push(completion_function_definition(name, level, long_options, short_options, subcommands))

    command_class.class_variable_get(:@@subcommands).each do |element|
      generate_functions(element[1].class, full_subcommand_name(name, element[0].to_s), level + 1)
    end
  end
end
